import * as amplitude from '@amplitude/analytics-node'
import * as Sentry from '@sentry/node'
import { Request, Response } from 'express'
import { GoogleSpreadsheet } from 'google-spreadsheet'
import { StatusCodes } from 'http-status-codes'
import nodemailer from 'nodemailer'
import Stripe from 'stripe'
import { v4 as uuidv4 } from 'uuid'

import { getEmailTemplate } from '../emailTemplate'

amplitude.init(
  process.env.NODE_ENV === 'production'
    ? process.env.AMPLITUDE_API_KEY ?? ''
    : ''
)

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY ?? '', {
  apiVersion: '2022-08-01',
})

const getSheet = async () => {
  const doc = new GoogleSpreadsheet(process.env.GSHEET_ID)

  await doc.useServiceAccountAuth({
    // env var values are copied from service account credentials generated by google
    // see "Authentication" section in docs for more info
    client_email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL ?? '',
    private_key: (process.env.GOOGLE_PRIVATE_KEY ?? '').replace(/\\n/g, '\n'),
  })

  await doc.loadInfo()
  return doc.sheetsByIndex[0]
}

export const handleStripeWebhookEvent = async (req: Request, res: Response) => {
  const sig = req.headers['stripe-signature']

  let event: Stripe.Event

  try {
    if (!sig) {
      throw new Error('missing sig')
    }

    event = stripe.webhooks.constructEvent(
      req.body,
      sig,
      process.env.STRIPE_WEBHOOK_SECRET ?? ''
    )
  } catch (err: unknown) {
    if (err instanceof Error) {
      Sentry.captureException(err)
      console.log(`âŒ Error message: ${err.message}`)
    }
    return res.status(StatusCodes.BAD_REQUEST).send(`Webhook Error: ${err}`)
  }

  // Handling one-time payments
  if (event.type === 'payment_intent.succeeded') {
    const stripeObject: Stripe.PaymentIntent = event.data
      .object as Stripe.PaymentIntent

    const invoice = stripeObject.charges?.data[0].invoice

    // Only send a new license key on 'payment_intent.succeeded' if there's no associated invoice
    if (!invoice) {
      const customerEmail =
        stripeObject.charges?.data[0].billing_details.email ??
        'help.leftonread@gmail.com'
      if (
        customerEmail === 'help.leftonread@gmail.com' &&
        process.env.NODE_ENV === 'production'
      ) {
        throw new Error('Missing customer email')
      }

      const licenseKey = await createLicenseKey({
        periodEnd: '',
        customerEmail,
      })
      void sendLicenseKey({ licenseKey, customerEmail })
    }
    return res.status(StatusCodes.OK).send()
  }

  // Handling subscription payments
  if (event.type === 'invoice.payment_succeeded') {
    const stripeObject: Stripe.Invoice = event.data.object as Stripe.Invoice
    const { customer_email, period_end, billing_reason } = stripeObject
    const customerEmail = customer_email ?? 'help.leftonread@gmail.com'
    if (
      customerEmail === 'help.leftonread@gmail.com' &&
      process.env.NODE_ENV === 'production'
    ) {
      throw new Error('Missing customer email')
    }

    // Only send a license key if this is a new subscription (or manual for testing purposes)
    if (
      billing_reason === 'subscription_create' ||
      billing_reason === 'manual'
    ) {
      const periodEnd = new Date(period_end * 1000).toUTCString()
      const licenseKey = await createLicenseKey({
        periodEnd,
        customerEmail,
      })
      void sendLicenseKey({ licenseKey, customerEmail })
    }

    return res.status(StatusCodes.OK).send()
  }

  const checkIsTest = () => {
    const subObj: Stripe.Subscription = event.data.object as Stripe.Subscription

    if (subObj.discount?.coupon.name === process.env.TEST_COUPON) {
      return true
    }

    return false
  }

  // Some logging stuff
  if (event.type === 'customer.subscription.created') {
    if (checkIsTest() || event.id === 'evt_1LiAxRCOCv5gqga3OjlbDRPy') {
      return res.status(StatusCodes.OK).send()
    }

    await amplitude.track('SUBSCRIPTION_CREATED', undefined, {
      device_id: 'server',
    })

    return res.status(StatusCodes.OK).send()
  }

  if (event.type === 'customer.subscription.updated') {
    if (
      checkIsTest() ||
      event.id === 'evt_1LiAzqCOCv5gqga31fdlcrx0' ||
      event.id === 'evt_1LiAzyCOCv5gqga3h0VrH4na'
    ) {
      return res.status(StatusCodes.OK).send()
    }
    const stripeObject: Stripe.Subscription = event.data
      .object as Stripe.Subscription

    const previousAttributes = event.data
      .previous_attributes as Stripe.Subscription

    const isCancelled =
      stripeObject.cancel_at ||
      stripeObject.cancel_at_period_end ||
      stripeObject.canceled_at

    const wasCancelled =
      previousAttributes?.cancel_at ||
      stripeObject?.cancel_at_period_end ||
      stripeObject?.canceled_at

    if (isCancelled && !wasCancelled) {
      await amplitude.track('SUBSCRIPTION_CANCELLED', undefined, {
        device_id: 'server',
      })
    }

    if (!isCancelled && wasCancelled) {
      await amplitude.track('SUBSCRIPTION_RENEWED', undefined, {
        device_id: 'server',
      })
    }

    return res.status(StatusCodes.OK).send()
  }

  return res.status(StatusCodes.OK).send()
}

function sendLicenseKey({
  customerEmail,
  licenseKey,
}: {
  customerEmail: string
  licenseKey: string
}) {
  // Compose email with License Key
  const transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
      user: process.env.EMAIL || '',
      pass: process.env.EMAIL_PASSWORD || '',
    },
  })

  const mailOptions = {
    from: process.env.EMAIL, // TODO: Perhaps update this email?
    to: customerEmail,
    subject: `Left on Read: Gold Unlocked!`,
    html: getEmailTemplate(licenseKey),
  }

  // Send the email
  transporter.sendMail(mailOptions, function (err) {
    if (err) {
      throw err
    }
  })
}

async function createLicenseKey({
  periodEnd,
  customerEmail,
}: {
  periodEnd: string
  customerEmail: string
}) {
  if (!customerEmail) {
    throw new Error('Missing customer email')
  }
  const emoji = ['joy', 'heart-emoji', 'peach', 'party-popper', 'eyes-emoji']
  //  Generate license key
  const licenseKey = `LOR-${
    emoji[Math.floor(Math.random() * emoji.length)]
  }-${uuidv4().slice(0, 27)}`

  // Insert metadata into database
  const gsheet = await getSheet()
  await gsheet.addRow({
    licenseKey,
    customerEmail,
    periodEnd,
  })

  return licenseKey
}

export const verifyLicenseKey = async (req: Request, res: Response) => {
  const { licenseKey, registrationId } = req.body

  const sheet = await getSheet()
  const rows = await sheet.getRows()

  const foundRow = rows.find((row) => row.licenseKey === licenseKey)

  if (!foundRow) {
    return res.status(StatusCodes.BAD_REQUEST).json({
      isActivated: false,
      message: 'This is an invalid license key.',
    })
  }

  if (
    foundRow.registrationId !== '' &&
    foundRow.registrationId !== undefined &&
    foundRow.registrationId !== registrationId
  ) {
    return res.status(StatusCodes.BAD_REQUEST).json({
      isActivated: false,
      message: 'This license key has already been registered.',
    })
  }

  foundRow.registrationId = registrationId
  await foundRow.save()

  return res.status(StatusCodes.OK).json({
    isActivated: true,
    message: 'License key activated!',
  })
}
